{'role': 'assistant', 'content': 'Now let\'s create the library controller:\n\n<function_calls>\n<create-file file_path="server/src/controllers/library.controller.ts">\nimport { Request, Response } from \'express\';\nimport { db } from \'../db\';\nimport { books, bookIssues } from \'../db/schema\';\nimport { eq, and, or, sql, desc, asc, like, lte, gte } from \'drizzle-orm\';\n\n// Get all books\nexport const getBooks = async (req: Request, res: Response) => {\n  try {\n    const { search, category, language, isActive } = req.query;\n\n    const conditions = [];\n    \n    if (search) {\n      const searchTerm = `%${search}%`;\n      conditions.push(\n        or(\n          like(books.title, searchTerm),\n          like(books.author, searchTerm),\n          like(books.isbn, searchTerm)\n        )\n      );\n    }\n    \n    if (category) conditions.push(eq(books.category, category as string));\n    if (language) conditions.push(eq(books.language, language as string));\n    if (isActive !== undefined) conditions.push(eq(books.isActive, isActive === \'true\'));\n\n    let query = db.select().from(books);\n\n    if (conditions.length > 0) {\n      query = query.where(and(...conditions)) as any;\n    }\n\n    const booksList = await query.orderBy(asc(books.title));\n\n    res.json({\n      success: true,\n      books: booksList,\n    });\n  } catch (error) {\n    console.error(\'Get books error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch books\',\n    });\n  }\n};\n\n// Get book by ID\nexport const getBookById = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    const book = await db.select().from(books).where(eq(books.id, id)).limit(1);\n\n    if (!book.length) {\n      return res.status(404).json({\n        success: false,\n        message: \'Book not found\',\n      });\n    }\n\n    // Get issue history for this book\n    const issues = await db\n      .select({\n        issue: bookIssues,\n        student: {\n          id: sql`students.id`,\n          studentId: sql`students.student_id`,\n          firstName: sql`students.first_name`,\n          lastName: sql`students.last_name`,\n        },\n      })\n      .from(bookIssues)\n      .innerJoin(sql`students`, eq(bookIssues.studentId, sql`students.id`))\n      .where(eq(bookIssues.bookId, id))\n      .orderBy(desc(bookIssues.issueDate));\n\n    res.json({\n      success: true,\n      book: {\n        ...book[0],\n        issues,\n      },\n    });\n  } catch (error) {\n    console.error(\'Get book error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch book\',\n    });\n  }\n};\n\n// Create book\nexport const createBook = async (req: Request, res: Response) => {\n  try {\n    const {\n      title,\n      author,\n      isbn,\n      publisher,\n      publicationYear,\n      category,\n      language,\n      edition,\n      pages,\n      totalQuantity,\n      shelfLocation,\n      description,\n      coverImage,\n      price,\n    } = req.body;\n\n    const newBook = await db\n      .insert(books)\n      .values({\n        title,\n        author,\n        isbn,\n        publisher,\n        publicationYear,\n        category,\n        language: language || \'English\',\n        edition,\n        pages,\n        totalQuantity,\n        availableQuantity: totalQuantity, // Initially all books are available\n        shelfLocation,\n        description,\n        coverImage,\n        price,\n      })\n      .returning();\n\n    res.status(201).json({\n      success: true,\n      message: \'Book added successfully\',\n      book: newBook[0],\n    });\n  } catch (error) {\n    console.error(\'Create book error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to add book\',\n    });\n  }\n};\n\n// Update book\nexport const updateBook = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const updateData = req.body;\n\n    // If totalQuantity is updated, adjust availableQuantity proportionally\n    if (updateData.totalQuantity !== undefined) {\n      const book = await db.select().from(books).where(eq(books.id, id)).limit(1);\n      \n      if (book.length) {\n        const issuedBooks = book[0].totalQuantity - book[0].availableQuantity;\n        updateData.availableQuantity = Math.max(0, updateData.totalQuantity - issuedBooks);\n      }\n    }\n\n    const updated = await db\n      .update(books)\n      .set({ ...updateData, updatedAt: new Date() })\n      .where(eq(books.id, id))\n      .returning();\n\n    if (!updated.length) {\n      return res.status(404).json({\n        success: false,\n        message: \'Book not found\',\n      });\n    }\n\n    res.json({\n      success: true,\n      message: \'Book updated successfully\',\n      book: updated[0],\n    });\n  } catch (error) {\n    console.error(\'Update book error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to update book\',\n    });\n  }\n};\n\n// Delete book\nexport const deleteBook = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    // Check if book has active issues\n    const activeIssues = await db\n      .select()\n      .from(bookIssues)\n      .where(and(eq(bookIssues.bookId, id), eq(bookIssues.status, \'issued\')));\n\n    if (activeIssues.length > 0) {\n      return res.status(400).json({\n        success: false,\n        message: \'Cannot delete book with active issues\',\n      });\n    }\n\n    await db.delete(books).where(eq(books.id, id));\n\n    res.json({\n      success: true,\n      message: \'Book deleted successfully\',\n    });\n  } catch (error) {\n    console.error(\'Delete book error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to delete book\',\n    });\n  }\n};\n\n// Issue book to student\nexport const issueBook = async (req: Request, res: Response) => {\n  try {\n    const { bookId, studentId, issueDate, dueDate, remarks } = req.body;\n    const userId = (req as any).user.id;\n\n    // Check if book exists and is available\n    const book = await db.select().from(books).where(eq(books.id, bookId)).limit(1);\n\n    if (!book.length) {\n      return res.status(404).json({\n        success: false,\n        message: \'Book not found\',\n      });\n    }\n\n    if (book[0].availableQuantity <= 0) {\n      return res.status(400).json({\n        success: false,\n        message: \'Book is not available\',\n      });\n    }\n\n    // Check if student already has this book issued\n    const existingIssue = await db\n      .select()\n      .from(bookIssues)\n      .where(\n        and(\n          eq(bookIssues.bookId, bookId),\n          eq(bookIssues.studentId, studentId),\n          eq(bookIssues.status, \'issued\')\n        )\n      );\n\n    if (existingIssue.length > 0) {\n      return res.status(400).json({\n        success: false,\n        message: \'Student already has this book issued\',\n      });\n    }\n\n    // Create issue record\n    const issue = await db\n      .insert(bookIssues)\n      .values({\n        bookId,\n        studentId,\n        issueDate,\n        dueDate,\n        remarks,\n        issuedBy: userId,\n      })\n      .returning();\n\n    // Update book available quantity\n    await db\n      .update(books)\n      .set({\n        availableQuantity: book[0].availableQuantity - 1,\n        updatedAt: new Date(),\n      })\n      .where(eq(books.id, bookId));\n\n    res.status(201).json({\n      success: true,\n      message: \'Book issued successfully\',\n      issue: issue[0],\n    });\n  } catch (error) {\n    console.error(\'Issue book error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to issue book\',\n    });\n  }\n};\n\n// Return book\nexport const returnBook = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const { returnDate, fineAmount, remarks } = req.body;\n    const userId = (req as any).user.id;\n\n    const issue = await db.select().from(bookIssues).where(eq(bookIssues.id, id)).limit(1);\n\n    if (!issue.length) {\n      return res.status(404).json({\n        success: false,\n        message: \'Issue record not found\',\n      });\n    }\n\n    if (issue[0].status !== \'issued\') {\n      return res.status(400).json({\n        success: false,\n        message: \'Book is not currently issued\',\n      });\n    }\n\n    // Update issue record\n    await db\n      .update(bookIssues)\n      .set({\n        status: \'returned\',\n        returnDate,\n        fineAmount: fineAmount || 0,\n        remarks: remarks || issue[0].remarks,\n        returnedBy: userId,\n        updatedAt: new Date(),\n      })\n      .where(eq(bookIssues.id, id));\n\n    // Update book available quantity\n    await db.execute(sql`\n      UPDATE books \n      SET available_quantity = available_quantity + 1,\n          updated_at = NOW()\n      WHERE id = ${issue[0].bookId}\n    `);\n\n    res.json({\n      success: true,\n      message: \'Book returned successfully\',\n    });\n  } catch (error) {\n    console.error(\'Return book error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to return book\',\n    });\n  }\n};\n\n// Get book issues\nexport const getBookIssues = async (req: Request, res: Response) => {\n  try {\n    const { bookId, studentId, status } = req.query;\n\n    const conditions = [];\n    if (bookId) conditions.push(eq(bookIssues.bookId, bookId as string));\n    if (studentId) conditions.push(eq(bookIssues.studentId, studentId as string));\n    if (status) conditions.push(eq(bookIssues.status, status as string));\n\n    let query = db\n      .select({\n        issue: bookIssues,\n        book: books,\n        student: {\n          id: sql`students.id`,\n          studentId: sql`students.student_id`,\n          firstName: sql`students.first_name`,\n          lastName: sql`students.last_name`,\n          email: sql`students.email`,\n        },\n      })\n      .from(bookIssues)\n      .innerJoin(books, eq(bookIssues.bookId, books.id))\n      .innerJoin(sql`students`, eq(bookIssues.studentId, sql`students.id`));\n\n    if (conditions.length > 0) {\n      query = query.where(and(...conditions)) as any;\n    }\n\n    const issues = await query.orderBy(desc(bookIssues.issueDate));\n\n    res.json({\n      success: true,\n      issues,\n    });\n  } catch (error) {\n    console.error(\'Get issues error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch issues\',\n    });\n  }\n};\n\n// Get student\'s issued books\nexport const getStudentBooks = async (req: Request, res: Response) => {\n  try {\n    const { studentId } = req.params;\n\n    const issues = await db\n      .select({\n        issue: bookIssues,\n        book: books,\n      })\n      .from(bookIssues)\n      .innerJoin(books, eq(bookIssues.bookId, books.id))\n      .where(and(eq(bookIssues.studentId, studentId), eq(bookIssues.status, \'issued\')))\n      .orderBy(desc(bookIssues.issueDate));\n\n    res.json({\n      success: true,\n      issues,\n    });\n  } catch (error) {\n    console.error(\'Get student books error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch student books\',\n    });\n  }\n};\n\n// Get library statistics\nexport const getLibraryStatistics = async (req: Request, res: Response) => {\n  try {\n    const stats = await db.execute(sql`\n      SELECT \n        COUNT(DISTINCT b.id) as total_books,\n        SUM(b.total_quantity) as total_copies,\n        SUM(b.available_quantity) as available_copies,\n        COUNT(DISTINCT CASE WHEN bi.status = \'issued\' THEN bi.id END) as issued_books,\n        COUNT(DISTINCT CASE WHEN bi.status = \'overdue\' THEN bi.id END) as overdue_books,\n        COUNT(DISTINCT b.category) as total_categories\n      FROM books b\n      LEFT JOIN book_issues bi ON b.id = bi.book_id\n      WHERE b.is_active = true\n    `);\n\n    res.json({\n      success: true,\n      statistics: stats.rows[0],\n    });\n  } catch (error) {\n    console.error(\'Get statistics error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch statistics\',\n    });\n  }\n};\n\n// Get book categories\nexport const getBookCategories = async (req: Request, res: Response) => {\n  try {\n    const categories = await db.execute(sql`\n      SELECT DISTINCT category, COUNT(*) as book_count\n      FROM books\n      WHERE is_active = true\n      GROUP BY category\n      ORDER BY category\n    `);\n\n    res.json({\n      success: true,\n      categories: categories.rows,\n    });\n  } catch (error) {\n    console.error(\'Get categories error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch categories\',\n    });\n  }\n};\n\n// Update overdue status (should be run periodically)\nexport const updateOverdueStatus = async (req: Request, res: Response) => {\n  try {\n    const today = new Date().toISOString().split(\'T\')[0];\n\n    await db\n      .update(bookIssues)\n      .set({ status: \'overdue\', updatedAt: new Date() })\n      .where(and(eq(bookIssues.status, \'issued\'), lte(bookIssues.dueDate, today)));\n\n    res.json({\n      success: true,\n      message: \'Overdue status updated successfully\',\n    });\n  } catch (error) {\n    console.error(\'Update overdue error:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to update overdue status\',\n    });\n  }\n};\n</create-file>\n</function_calls>'}