{'role': 'assistant', 'content': 'Now let me create the expenses controller:\n\n<function_calls>\n<create-file file_path="server/src/controllers/expenses.controller.ts">\nimport { Request, Response } from \'express\';\nimport { db } from \'../db\';\nimport { expenseCategories, expenses, users } from \'../db/schema\';\nimport { eq, and, desc, sql, gte, lte } from \'drizzle-orm\';\n\n// Get all expense categories\nexport const getExpenseCategories = async (req: Request, res: Response) => {\n  try {\n    const categories = await db\n      .select()\n      .from(expenseCategories)\n      .where(eq(expenseCategories.isActive, true))\n      .orderBy(expenseCategories.name);\n\n    res.status(200).json({\n      success: true,\n      data: categories,\n    });\n  } catch (error) {\n    console.error(\'Error fetching expense categories:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch expense categories\',\n    });\n  }\n};\n\n// Create expense\nexport const createExpense = async (req: Request, res: Response) => {\n  try {\n    const {\n      categoryId,\n      title,\n      description,\n      amount,\n      expenseDate,\n      paymentMethod,\n      invoiceNumber,\n      vendorName,\n      remarks,\n    } = req.body;\n\n    const recordedBy = req.user!.id;\n\n    // Validate required fields\n    if (!categoryId || !title || !amount || !expenseDate || !paymentMethod) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required fields\',\n      });\n    }\n\n    const [expense] = await db\n      .insert(expenses)\n      .values({\n        categoryId,\n        title,\n        description: description || null,\n        amount: amount.toString(),\n        expenseDate,\n        paymentMethod,\n        invoiceNumber: invoiceNumber || null,\n        vendorName: vendorName || null,\n        remarks: remarks || null,\n        recordedBy,\n      })\n      .returning();\n\n    res.status(201).json({\n      success: true,\n      message: \'Expense recorded successfully\',\n      data: expense,\n    });\n  } catch (error) {\n    console.error(\'Error creating expense:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to record expense\',\n    });\n  }\n};\n\n// Get all expenses\nexport const getExpenses = async (req: Request, res: Response) => {\n  try {\n    const { startDate, endDate, categoryId } = req.query;\n\n    let query = db\n      .select({\n        id: expenses.id,\n        title: expenses.title,\n        description: expenses.description,\n        amount: expenses.amount,\n        expenseDate: expenses.expenseDate,\n        paymentMethod: expenses.paymentMethod,\n        invoiceNumber: expenses.invoiceNumber,\n        vendorName: expenses.vendorName,\n        remarks: expenses.remarks,\n        category: {\n          id: expenseCategories.id,\n          name: expenseCategories.name,\n        },\n        recordedBy: sql<string>`${users.firstName} || \' \' || ${users.lastName}`,\n        createdAt: expenses.createdAt,\n      })\n      .from(expenses)\n      .leftJoin(expenseCategories, eq(expenses.categoryId, expenseCategories.id))\n      .leftJoin(users, eq(expenses.recordedBy, users.id));\n\n    if (startDate && endDate) {\n      query = query.where(\n        and(\n          gte(expenses.expenseDate, startDate as string),\n          lte(expenses.expenseDate, endDate as string)\n        )\n      );\n    }\n\n    if (categoryId) {\n      query = query.where(eq(expenses.categoryId, categoryId as string));\n    }\n\n    const allExpenses = await query.orderBy(desc(expenses.expenseDate));\n\n    res.status(200).json({\n      success: true,\n      data: allExpenses,\n    });\n  } catch (error) {\n    console.error(\'Error fetching expenses:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch expenses\',\n    });\n  }\n};\n\n// Get expense by ID\nexport const getExpenseById = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    const [expense] = await db\n      .select({\n        id: expenses.id,\n        title: expenses.title,\n        description: expenses.description,\n        amount: expenses.amount,\n        expenseDate: expenses.expenseDate,\n        paymentMethod: expenses.paymentMethod,\n        invoiceNumber: expenses.invoiceNumber,\n        vendorName: expenses.vendorName,\n        remarks: expenses.remarks,\n        category: {\n          id: expenseCategories.id,\n          name: expenseCategories.name,\n        },\n        recordedBy: sql<string>`${users.firstName} || \' \' || ${users.lastName}`,\n        createdAt: expenses.createdAt,\n      })\n      .from(expenses)\n      .leftJoin(expenseCategories, eq(expenses.categoryId, expenseCategories.id))\n      .leftJoin(users, eq(expenses.recordedBy, users.id))\n      .where(eq(expenses.id, id));\n\n    if (!expense) {\n      return res.status(404).json({\n        success: false,\n        message: \'Expense not found\',\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      data: expense,\n    });\n  } catch (error) {\n    console.error(\'Error fetching expense:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch expense\',\n    });\n  }\n};\n\n// Update expense\nexport const updateExpense = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n    const {\n      categoryId,\n      title,\n      description,\n      amount,\n      expenseDate,\n      paymentMethod,\n      invoiceNumber,\n      vendorName,\n      remarks,\n    } = req.body;\n\n    const [updated] = await db\n      .update(expenses)\n      .set({\n        categoryId,\n        title,\n        description,\n        amount: amount.toString(),\n        expenseDate,\n        paymentMethod,\n        invoiceNumber,\n        vendorName,\n        remarks,\n        updatedAt: new Date(),\n      })\n      .where(eq(expenses.id, id))\n      .returning();\n\n    if (!updated) {\n      return res.status(404).json({\n        success: false,\n        message: \'Expense not found\',\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      message: \'Expense updated successfully\',\n      data: updated,\n    });\n  } catch (error) {\n    console.error(\'Error updating expense:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to update expense\',\n    });\n  }\n};\n\n// Delete expense\nexport const deleteExpense = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    await db.delete(expenses).where(eq(expenses.id, id));\n\n    res.status(200).json({\n      success: true,\n      message: \'Expense deleted successfully\',\n    });\n  } catch (error) {\n    console.error(\'Error deleting expense:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to delete expense\',\n    });\n  }\n};\n\n// Get expense statistics\nexport const getExpenseStatistics = async (req: Request, res: Response) => {\n  try {\n    const { startDate, endDate } = req.query;\n\n    let query = db\n      .select({\n        categoryName: expenseCategories.name,\n        totalAmount: sql<number>`SUM(CAST(${expenses.amount} AS DECIMAL))`,\n        expenseCount: sql<number>`COUNT(*)`,\n      })\n      .from(expenses)\n      .leftJoin(expenseCategories, eq(expenses.categoryId, expenseCategories.id));\n\n    if (startDate && endDate) {\n      query = query.where(\n        and(\n          gte(expenses.expenseDate, startDate as string),\n          lte(expenses.expenseDate, endDate as string)\n        )\n      );\n    }\n\n    const categoryStats = await query\n      .groupBy(expenseCategories.name)\n      .orderBy(desc(sql`SUM(CAST(${expenses.amount} AS DECIMAL))`));\n\n    // Get total expenses\n    const totalQuery = db\n      .select({\n        total: sql<number>`SUM(CAST(${expenses.amount} AS DECIMAL))`,\n        count: sql<number>`COUNT(*)`,\n      })\n      .from(expenses);\n\n    if (startDate && endDate) {\n      totalQuery.where(\n        and(\n          gte(expenses.expenseDate, startDate as string),\n          lte(expenses.expenseDate, endDate as string)\n        )\n      );\n    }\n\n    const [totals] = await totalQuery;\n\n    res.status(200).json({\n      success: true,\n      data: {\n        categoryStats,\n        totals,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error fetching expense statistics:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch statistics\',\n    });\n  }\n};\n\n// Get financial summary (income vs expense)\nexport const getFinancialSummary = async (req: Request, res: Response) => {\n  try {\n    const { startDate, endDate } = req.query;\n\n    // Get total income (fee payments)\n    const incomeQuery = db\n      .select({\n        total: sql<number>`SUM(CAST(fee_payments.amount AS DECIMAL))`,\n      })\n      .from(sql`fee_payments`);\n\n    if (startDate && endDate) {\n      incomeQuery.where(\n        and(\n          gte(sql`fee_payments.payment_date`, startDate as string),\n          lte(sql`fee_payments.payment_date`, endDate as string)\n        )\n      );\n    }\n\n    const [income] = await incomeQuery;\n\n    // Get total expenses\n    const expenseQuery = db\n      .select({\n        total: sql<number>`SUM(CAST(${expenses.amount} AS DECIMAL))`,\n      })\n      .from(expenses);\n\n    if (startDate && endDate) {\n      expenseQuery.where(\n        and(\n          gte(expenses.expenseDate, startDate as string),\n          lte(expenses.expenseDate, endDate as string)\n        )\n      );\n    }\n\n    const [expense] = await expenseQuery;\n\n    const totalIncome = income?.total || 0;\n    const totalExpense = expense?.total || 0;\n    const netBalance = totalIncome - totalExpense;\n\n    res.status(200).json({\n      success: true,\n      data: {\n        totalIncome,\n        totalExpense,\n        netBalance,\n        profitMargin: totalIncome > 0 ? ((netBalance / totalIncome) * 100).toFixed(2) : 0,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error fetching financial summary:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch financial summary\',\n    });\n  }\n};\n</create-file>\n</function_calls>'}