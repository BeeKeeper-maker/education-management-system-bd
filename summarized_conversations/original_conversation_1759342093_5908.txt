{'role': 'assistant', 'content': 'Perfect! Now let me create the financial controllers. I\'ll start with the fees controller:\n\n<function_calls>\n<create-file file_path="server/src/controllers/fees.controller.ts">\nimport { Request, Response } from \'express\';\nimport { db } from \'../db\';\nimport {\n  feeCategories,\n  feeStructures,\n  feeStructureItems,\n  studentFees,\n  feePayments,\n  feeDiscounts,\n  students,\n  users,\n  classes,\n  academicSessions,\n} from \'../db/schema\';\nimport { eq, and, desc, sql, gte, lte } from \'drizzle-orm\';\n\n// Get all fee categories\nexport const getFeeCategories = async (req: Request, res: Response) => {\n  try {\n    const categories = await db\n      .select()\n      .from(feeCategories)\n      .where(eq(feeCategories.isActive, true))\n      .orderBy(feeCategories.name);\n\n    res.status(200).json({\n      success: true,\n      data: categories,\n    });\n  } catch (error) {\n    console.error(\'Error fetching fee categories:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch fee categories\',\n    });\n  }\n};\n\n// Create fee structure\nexport const createFeeStructure = async (req: Request, res: Response) => {\n  try {\n    const { name, academicSessionId, classId, description, items } = req.body;\n\n    // Validate required fields\n    if (!name || !academicSessionId || !items || !Array.isArray(items)) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required fields\',\n      });\n    }\n\n    // Create fee structure\n    const [feeStructure] = await db\n      .insert(feeStructures)\n      .values({\n        name,\n        academicSessionId,\n        classId: classId || null,\n        description: description || null,\n        isActive: true,\n      })\n      .returning();\n\n    // Create fee structure items\n    const itemsData = items.map((item: any) => ({\n      feeStructureId: feeStructure.id,\n      feeCategoryId: item.feeCategoryId,\n      amount: item.amount.toString(),\n      dueDate: item.dueDate || null,\n      isOptional: item.isOptional || false,\n    }));\n\n    await db.insert(feeStructureItems).values(itemsData);\n\n    res.status(201).json({\n      success: true,\n      message: \'Fee structure created successfully\',\n      data: feeStructure,\n    });\n  } catch (error) {\n    console.error(\'Error creating fee structure:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to create fee structure\',\n    });\n  }\n};\n\n// Get all fee structures\nexport const getFeeStructures = async (req: Request, res: Response) => {\n  try {\n    const { academicSessionId, classId } = req.query;\n\n    let query = db\n      .select({\n        id: feeStructures.id,\n        name: feeStructures.name,\n        description: feeStructures.description,\n        isActive: feeStructures.isActive,\n        academicSession: {\n          id: academicSessions.id,\n          name: academicSessions.name,\n        },\n        class: {\n          id: classes.id,\n          name: classes.name,\n        },\n        createdAt: feeStructures.createdAt,\n      })\n      .from(feeStructures)\n      .leftJoin(academicSessions, eq(feeStructures.academicSessionId, academicSessions.id))\n      .leftJoin(classes, eq(feeStructures.classId, classes.id));\n\n    if (academicSessionId) {\n      query = query.where(eq(feeStructures.academicSessionId, academicSessionId as string));\n    }\n\n    if (classId) {\n      query = query.where(eq(feeStructures.classId, classId as string));\n    }\n\n    const structures = await query.orderBy(desc(feeStructures.createdAt));\n\n    res.status(200).json({\n      success: true,\n      data: structures,\n    });\n  } catch (error) {\n    console.error(\'Error fetching fee structures:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch fee structures\',\n    });\n  }\n};\n\n// Get fee structure by ID with items\nexport const getFeeStructureById = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    const [structure] = await db\n      .select()\n      .from(feeStructures)\n      .where(eq(feeStructures.id, id));\n\n    if (!structure) {\n      return res.status(404).json({\n        success: false,\n        message: \'Fee structure not found\',\n      });\n    }\n\n    const items = await db\n      .select({\n        id: feeStructureItems.id,\n        amount: feeStructureItems.amount,\n        dueDate: feeStructureItems.dueDate,\n        isOptional: feeStructureItems.isOptional,\n        category: {\n          id: feeCategories.id,\n          name: feeCategories.name,\n          description: feeCategories.description,\n        },\n      })\n      .from(feeStructureItems)\n      .leftJoin(feeCategories, eq(feeStructureItems.feeCategoryId, feeCategories.id))\n      .where(eq(feeStructureItems.feeStructureId, id));\n\n    res.status(200).json({\n      success: true,\n      data: {\n        ...structure,\n        items,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error fetching fee structure:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch fee structure\',\n    });\n  }\n};\n\n// Assign fee structure to student\nexport const assignFeeToStudent = async (req: Request, res: Response) => {\n  try {\n    const { studentId, feeStructureId, academicSessionId } = req.body;\n\n    // Get fee structure items\n    const items = await db\n      .select()\n      .from(feeStructureItems)\n      .where(eq(feeStructureItems.feeStructureId, feeStructureId));\n\n    const totalAmount = items.reduce((sum, item) => sum + parseFloat(item.amount), 0);\n\n    // Check if already assigned\n    const existing = await db\n      .select()\n      .from(studentFees)\n      .where(\n        and(\n          eq(studentFees.studentId, studentId),\n          eq(studentFees.feeStructureId, feeStructureId),\n          eq(studentFees.academicSessionId, academicSessionId)\n        )\n      );\n\n    if (existing.length > 0) {\n      return res.status(400).json({\n        success: false,\n        message: \'Fee structure already assigned to this student\',\n      });\n    }\n\n    const [studentFee] = await db\n      .insert(studentFees)\n      .values({\n        studentId,\n        feeStructureId,\n        academicSessionId,\n        totalAmount: totalAmount.toString(),\n        paidAmount: \'0\',\n        discountAmount: \'0\',\n        waiverAmount: \'0\',\n        dueAmount: totalAmount.toString(),\n        status: \'pending\',\n      })\n      .returning();\n\n    res.status(201).json({\n      success: true,\n      message: \'Fee assigned to student successfully\',\n      data: studentFee,\n    });\n  } catch (error) {\n    console.error(\'Error assigning fee:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to assign fee\',\n    });\n  }\n};\n\n// Collect fee payment\nexport const collectFeePayment = async (req: Request, res: Response) => {\n  try {\n    const {\n      studentFeeId,\n      studentId,\n      amount,\n      paymentDate,\n      paymentMethod,\n      transactionId,\n      remarks,\n    } = req.body;\n\n    const collectedBy = req.user!.id;\n\n    // Validate required fields\n    if (!studentFeeId || !studentId || !amount || !paymentDate || !paymentMethod) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required fields\',\n      });\n    }\n\n    // Get student fee details\n    const [studentFee] = await db\n      .select()\n      .from(studentFees)\n      .where(eq(studentFees.id, studentFeeId));\n\n    if (!studentFee) {\n      return res.status(404).json({\n        success: false,\n        message: \'Student fee not found\',\n      });\n    }\n\n    const dueAmount = parseFloat(studentFee.dueAmount);\n    const paymentAmount = parseFloat(amount);\n\n    if (paymentAmount > dueAmount) {\n      return res.status(400).json({\n        success: false,\n        message: \'Payment amount exceeds due amount\',\n      });\n    }\n\n    // Generate receipt number\n    const receiptNumber = `RCP${Date.now()}`;\n\n    // Create payment record\n    const [payment] = await db\n      .insert(feePayments)\n      .values({\n        studentFeeId,\n        studentId,\n        amount: amount.toString(),\n        paymentDate,\n        paymentMethod,\n        transactionId: transactionId || null,\n        receiptNumber,\n        remarks: remarks || null,\n        collectedBy,\n      })\n      .returning();\n\n    // Update student fee\n    const newPaidAmount = parseFloat(studentFee.paidAmount) + paymentAmount;\n    const newDueAmount = dueAmount - paymentAmount;\n    const newStatus = newDueAmount === 0 ? \'paid\' : newDueAmount < parseFloat(studentFee.totalAmount) ? \'partial\' : \'pending\';\n\n    await db\n      .update(studentFees)\n      .set({\n        paidAmount: newPaidAmount.toString(),\n        dueAmount: newDueAmount.toString(),\n        status: newStatus,\n        updatedAt: new Date(),\n      })\n      .where(eq(studentFees.id, studentFeeId));\n\n    res.status(201).json({\n      success: true,\n      message: \'Payment collected successfully\',\n      data: {\n        payment,\n        receiptNumber,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error collecting payment:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to collect payment\',\n    });\n  }\n};\n\n// Get student fees\nexport const getStudentFees = async (req: Request, res: Response) => {\n  try {\n    const { studentId } = req.params;\n    const { academicSessionId } = req.query;\n\n    let query = db\n      .select({\n        id: studentFees.id,\n        totalAmount: studentFees.totalAmount,\n        paidAmount: studentFees.paidAmount,\n        discountAmount: studentFees.discountAmount,\n        waiverAmount: studentFees.waiverAmount,\n        dueAmount: studentFees.dueAmount,\n        status: studentFees.status,\n        feeStructure: {\n          id: feeStructures.id,\n          name: feeStructures.name,\n        },\n        academicSession: {\n          id: academicSessions.id,\n          name: academicSessions.name,\n        },\n        createdAt: studentFees.createdAt,\n      })\n      .from(studentFees)\n      .leftJoin(feeStructures, eq(studentFees.feeStructureId, feeStructures.id))\n      .leftJoin(academicSessions, eq(studentFees.academicSessionId, academicSessions.id))\n      .where(eq(studentFees.studentId, studentId));\n\n    if (academicSessionId) {\n      query = query.where(\n        and(\n          eq(studentFees.studentId, studentId),\n          eq(studentFees.academicSessionId, academicSessionId as string)\n        )\n      );\n    }\n\n    const fees = await query.orderBy(desc(studentFees.createdAt));\n\n    res.status(200).json({\n      success: true,\n      data: fees,\n    });\n  } catch (error) {\n    console.error(\'Error fetching student fees:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch student fees\',\n    });\n  }\n};\n\n// Get payment history\nexport const getPaymentHistory = async (req: Request, res: Response) => {\n  try {\n    const { studentId } = req.params;\n    const { startDate, endDate } = req.query;\n\n    let query = db\n      .select({\n        id: feePayments.id,\n        amount: feePayments.amount,\n        paymentDate: feePayments.paymentDate,\n        paymentMethod: feePayments.paymentMethod,\n        transactionId: feePayments.transactionId,\n        receiptNumber: feePayments.receiptNumber,\n        remarks: feePayments.remarks,\n        collectedBy: sql<string>`${users.firstName} || \' \' || ${users.lastName}`,\n        createdAt: feePayments.createdAt,\n      })\n      .from(feePayments)\n      .leftJoin(users, eq(feePayments.collectedBy, users.id))\n      .where(eq(feePayments.studentId, studentId));\n\n    if (startDate && endDate) {\n      query = query.where(\n        and(\n          eq(feePayments.studentId, studentId),\n          gte(feePayments.paymentDate, startDate as string),\n          lte(feePayments.paymentDate, endDate as string)\n        )\n      );\n    }\n\n    const payments = await query.orderBy(desc(feePayments.paymentDate));\n\n    res.status(200).json({\n      success: true,\n      data: payments,\n    });\n  } catch (error) {\n    console.error(\'Error fetching payment history:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch payment history\',\n    });\n  }\n};\n\n// Get fee collection report\nexport const getFeeCollectionReport = async (req: Request, res: Response) => {\n  try {\n    const { startDate, endDate, classId } = req.query;\n\n    let query = db\n      .select({\n        date: feePayments.paymentDate,\n        totalAmount: sql<number>`SUM(CAST(${feePayments.amount} AS DECIMAL))`,\n        paymentCount: sql<number>`COUNT(*)`,\n      })\n      .from(feePayments);\n\n    if (startDate && endDate) {\n      query = query.where(\n        and(\n          gte(feePayments.paymentDate, startDate as string),\n          lte(feePayments.paymentDate, endDate as string)\n        )\n      );\n    }\n\n    const report = await query\n      .groupBy(feePayments.paymentDate)\n      .orderBy(desc(feePayments.paymentDate));\n\n    // Get outstanding dues\n    const outstandingQuery = db\n      .select({\n        totalDue: sql<number>`SUM(CAST(${studentFees.dueAmount} AS DECIMAL))`,\n        studentCount: sql<number>`COUNT(DISTINCT ${studentFees.studentId})`,\n      })\n      .from(studentFees)\n      .where(sql`CAST(${studentFees.dueAmount} AS DECIMAL) > 0`);\n\n    const [outstanding] = await outstandingQuery;\n\n    res.status(200).json({\n      success: true,\n      data: {\n        dailyCollection: report,\n        outstanding,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error fetching fee collection report:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch report\',\n    });\n  }\n};\n</create-file>\n</function_calls>'}