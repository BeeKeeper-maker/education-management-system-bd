{'role': 'assistant', 'content': 'Now let me create the timetable controller:\n\n<function_calls>\n<create-file file_path="server/src/controllers/timetable.controller.ts">\nimport { Request, Response } from \'express\';\nimport { db } from \'../db\';\nimport { periods, timetableEntries, classes, sections, subjects, users } from \'../db/schema\';\nimport { eq, and, sql } from \'drizzle-orm\';\n\n// Get all periods\nexport const getPeriods = async (req: Request, res: Response) => {\n  try {\n    const allPeriods = await db\n      .select()\n      .from(periods)\n      .orderBy(periods.orderIndex);\n\n    res.status(200).json({\n      success: true,\n      data: allPeriods,\n    });\n  } catch (error) {\n    console.error(\'Error fetching periods:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch periods\',\n    });\n  }\n};\n\n// Create or update timetable entry\nexport const createTimetableEntry = async (req: Request, res: Response) => {\n  try {\n    const { classId, sectionId, subjectId, teacherId, periodId, dayOfWeek, roomNumber } = req.body;\n\n    // Validate required fields\n    if (!classId || !sectionId || !periodId || dayOfWeek === undefined) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required fields\',\n      });\n    }\n\n    // Check for conflicts - same teacher at same time\n    if (teacherId) {\n      const conflict = await db\n        .select()\n        .from(timetableEntries)\n        .where(\n          and(\n            eq(timetableEntries.teacherId, teacherId),\n            eq(timetableEntries.periodId, periodId),\n            eq(timetableEntries.dayOfWeek, dayOfWeek)\n          )\n        );\n\n      if (conflict.length > 0) {\n        return res.status(400).json({\n          success: false,\n          message: \'Teacher is already assigned to another class at this time\',\n          conflict: conflict[0],\n        });\n      }\n    }\n\n    // Check if entry already exists for this class/section/period/day\n    const existing = await db\n      .select()\n      .from(timetableEntries)\n      .where(\n        and(\n          eq(timetableEntries.classId, classId),\n          eq(timetableEntries.sectionId, sectionId),\n          eq(timetableEntries.periodId, periodId),\n          eq(timetableEntries.dayOfWeek, dayOfWeek)\n        )\n      );\n\n    if (existing.length > 0) {\n      // Update existing entry\n      const [updated] = await db\n        .update(timetableEntries)\n        .set({\n          subjectId: subjectId || null,\n          teacherId: teacherId || null,\n          roomNumber: roomNumber || null,\n          updatedAt: new Date(),\n        })\n        .where(eq(timetableEntries.id, existing[0].id))\n        .returning();\n\n      return res.status(200).json({\n        success: true,\n        message: \'Timetable entry updated successfully\',\n        data: updated,\n      });\n    }\n\n    // Create new entry\n    const [newEntry] = await db\n      .insert(timetableEntries)\n      .values({\n        classId,\n        sectionId,\n        subjectId: subjectId || null,\n        teacherId: teacherId || null,\n        periodId,\n        dayOfWeek,\n        roomNumber: roomNumber || null,\n      })\n      .returning();\n\n    res.status(201).json({\n      success: true,\n      message: \'Timetable entry created successfully\',\n      data: newEntry,\n    });\n  } catch (error) {\n    console.error(\'Error creating timetable entry:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to create timetable entry\',\n    });\n  }\n};\n\n// Get timetable for a class/section\nexport const getClassTimetable = async (req: Request, res: Response) => {\n  try {\n    const { classId, sectionId } = req.query;\n\n    if (!classId || !sectionId) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required parameters\',\n      });\n    }\n\n    const timetable = await db\n      .select({\n        id: timetableEntries.id,\n        dayOfWeek: timetableEntries.dayOfWeek,\n        roomNumber: timetableEntries.roomNumber,\n        period: {\n          id: periods.id,\n          name: periods.name,\n          startTime: periods.startTime,\n          endTime: periods.endTime,\n          orderIndex: periods.orderIndex,\n          isBreak: periods.isBreak,\n        },\n        subject: {\n          id: subjects.id,\n          name: subjects.name,\n          code: subjects.code,\n        },\n        teacher: {\n          id: users.id,\n          name: sql<string>`${users.firstName} || \' \' || ${users.lastName}`,\n        },\n      })\n      .from(timetableEntries)\n      .leftJoin(periods, eq(timetableEntries.periodId, periods.id))\n      .leftJoin(subjects, eq(timetableEntries.subjectId, subjects.id))\n      .leftJoin(users, eq(timetableEntries.teacherId, users.id))\n      .where(\n        and(\n          eq(timetableEntries.classId, classId as string),\n          eq(timetableEntries.sectionId, sectionId as string)\n        )\n      )\n      .orderBy(timetableEntries.dayOfWeek, periods.orderIndex);\n\n    // Group by day of week\n    const groupedTimetable = timetable.reduce((acc: any, entry) => {\n      const day = entry.dayOfWeek;\n      if (!acc[day]) {\n        acc[day] = [];\n      }\n      acc[day].push(entry);\n      return acc;\n    }, {});\n\n    res.status(200).json({\n      success: true,\n      data: groupedTimetable,\n    });\n  } catch (error) {\n    console.error(\'Error fetching class timetable:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch timetable\',\n    });\n  }\n};\n\n// Get timetable for a teacher\nexport const getTeacherTimetable = async (req: Request, res: Response) => {\n  try {\n    const { teacherId } = req.params;\n\n    const timetable = await db\n      .select({\n        id: timetableEntries.id,\n        dayOfWeek: timetableEntries.dayOfWeek,\n        roomNumber: timetableEntries.roomNumber,\n        period: {\n          id: periods.id,\n          name: periods.name,\n          startTime: periods.startTime,\n          endTime: periods.endTime,\n          orderIndex: periods.orderIndex,\n          isBreak: periods.isBreak,\n        },\n        subject: {\n          id: subjects.id,\n          name: subjects.name,\n          code: subjects.code,\n        },\n        class: {\n          id: classes.id,\n          name: classes.name,\n        },\n        section: {\n          id: sections.id,\n          name: sections.name,\n        },\n      })\n      .from(timetableEntries)\n      .leftJoin(periods, eq(timetableEntries.periodId, periods.id))\n      .leftJoin(subjects, eq(timetableEntries.subjectId, subjects.id))\n      .leftJoin(classes, eq(timetableEntries.classId, classes.id))\n      .leftJoin(sections, eq(timetableEntries.sectionId, sections.id))\n      .where(eq(timetableEntries.teacherId, teacherId))\n      .orderBy(timetableEntries.dayOfWeek, periods.orderIndex);\n\n    // Group by day of week\n    const groupedTimetable = timetable.reduce((acc: any, entry) => {\n      const day = entry.dayOfWeek;\n      if (!acc[day]) {\n        acc[day] = [];\n      }\n      acc[day].push(entry);\n      return acc;\n    }, {});\n\n    res.status(200).json({\n      success: true,\n      data: groupedTimetable,\n    });\n  } catch (error) {\n    console.error(\'Error fetching teacher timetable:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch teacher timetable\',\n    });\n  }\n};\n\n// Delete timetable entry\nexport const deleteTimetableEntry = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    await db.delete(timetableEntries).where(eq(timetableEntries.id, id));\n\n    res.status(200).json({\n      success: true,\n      message: \'Timetable entry deleted successfully\',\n    });\n  } catch (error) {\n    console.error(\'Error deleting timetable entry:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to delete timetable entry\',\n    });\n  }\n};\n\n// Check for conflicts\nexport const checkConflicts = async (req: Request, res: Response) => {\n  try {\n    const { teacherId, periodId, dayOfWeek, excludeEntryId } = req.query;\n\n    if (!teacherId || !periodId || dayOfWeek === undefined) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required parameters\',\n      });\n    }\n\n    let query = db\n      .select({\n        id: timetableEntries.id,\n        className: classes.name,\n        sectionName: sections.name,\n        subjectName: subjects.name,\n        periodName: periods.name,\n        startTime: periods.startTime,\n        endTime: periods.endTime,\n      })\n      .from(timetableEntries)\n      .leftJoin(classes, eq(timetableEntries.classId, classes.id))\n      .leftJoin(sections, eq(timetableEntries.sectionId, sections.id))\n      .leftJoin(subjects, eq(timetableEntries.subjectId, subjects.id))\n      .leftJoin(periods, eq(timetableEntries.periodId, periods.id))\n      .where(\n        and(\n          eq(timetableEntries.teacherId, teacherId as string),\n          eq(timetableEntries.periodId, periodId as string),\n          eq(timetableEntries.dayOfWeek, parseInt(dayOfWeek as string))\n        )\n      );\n\n    const conflicts = await query;\n\n    // Filter out the entry being edited\n    const filteredConflicts = excludeEntryId\n      ? conflicts.filter(c => c.id !== excludeEntryId)\n      : conflicts;\n\n    res.status(200).json({\n      success: true,\n      hasConflict: filteredConflicts.length > 0,\n      conflicts: filteredConflicts,\n    });\n  } catch (error) {\n    console.error(\'Error checking conflicts:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to check conflicts\',\n    });\n  }\n};\n</create-file>\n</function_calls>'}