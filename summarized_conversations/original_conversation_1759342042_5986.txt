{'role': 'assistant', 'content': 'Now let me create the examinations controller:\n\n<function_calls>\n<create-file file_path="server/src/controllers/examinations.controller.ts">\nimport { Request, Response } from \'express\';\nimport { db } from \'../db\';\nimport {\n  examTypes,\n  exams,\n  examSubjects,\n  marks,\n  gradingSystem,\n  results,\n  subjectResults,\n  classes,\n  sections,\n  subjects,\n  students,\n  users,\n} from \'../db/schema\';\nimport { eq, and, desc, sql, inArray } from \'drizzle-orm\';\n\n// Get all exam types\nexport const getExamTypes = async (req: Request, res: Response) => {\n  try {\n    const types = await db\n      .select()\n      .from(examTypes)\n      .where(eq(examTypes.isActive, true))\n      .orderBy(examTypes.name);\n\n    res.status(200).json({\n      success: true,\n      data: types,\n    });\n  } catch (error) {\n    console.error(\'Error fetching exam types:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch exam types\',\n    });\n  }\n};\n\n// Create exam\nexport const createExam = async (req: Request, res: Response) => {\n  try {\n    const {\n      name,\n      examTypeId,\n      academicSessionId,\n      startDate,\n      endDate,\n      description,\n      instructions,\n    } = req.body;\n\n    const createdBy = req.user!.id;\n\n    // Validate required fields\n    if (!name || !examTypeId || !academicSessionId || !startDate || !endDate) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required fields\',\n      });\n    }\n\n    const [exam] = await db\n      .insert(exams)\n      .values({\n        name,\n        examTypeId,\n        academicSessionId,\n        startDate,\n        endDate,\n        description: description || null,\n        instructions: instructions || null,\n        isPublished: false,\n        resultsPublished: false,\n        createdBy,\n      })\n      .returning();\n\n    res.status(201).json({\n      success: true,\n      message: \'Exam created successfully\',\n      data: exam,\n    });\n  } catch (error) {\n    console.error(\'Error creating exam:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to create exam\',\n    });\n  }\n};\n\n// Get all exams\nexport const getExams = async (req: Request, res: Response) => {\n  try {\n    const { academicSessionId } = req.query;\n\n    let query = db\n      .select({\n        id: exams.id,\n        name: exams.name,\n        startDate: exams.startDate,\n        endDate: exams.endDate,\n        description: exams.description,\n        isPublished: exams.isPublished,\n        resultsPublished: exams.resultsPublished,\n        examType: {\n          id: examTypes.id,\n          name: examTypes.name,\n          weightage: examTypes.weightage,\n        },\n        createdAt: exams.createdAt,\n      })\n      .from(exams)\n      .leftJoin(examTypes, eq(exams.examTypeId, examTypes.id));\n\n    if (academicSessionId) {\n      query = query.where(eq(exams.academicSessionId, academicSessionId as string));\n    }\n\n    const allExams = await query.orderBy(desc(exams.createdAt));\n\n    res.status(200).json({\n      success: true,\n      data: allExams,\n    });\n  } catch (error) {\n    console.error(\'Error fetching exams:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch exams\',\n    });\n  }\n};\n\n// Get exam by ID\nexport const getExamById = async (req: Request, res: Response) => {\n  try {\n    const { id } = req.params;\n\n    const [exam] = await db\n      .select({\n        id: exams.id,\n        name: exams.name,\n        startDate: exams.startDate,\n        endDate: exams.endDate,\n        description: exams.description,\n        instructions: exams.instructions,\n        isPublished: exams.isPublished,\n        resultsPublished: exams.resultsPublished,\n        examType: {\n          id: examTypes.id,\n          name: examTypes.name,\n          weightage: examTypes.weightage,\n        },\n        createdAt: exams.createdAt,\n      })\n      .from(exams)\n      .leftJoin(examTypes, eq(exams.examTypeId, examTypes.id))\n      .where(eq(exams.id, id));\n\n    if (!exam) {\n      return res.status(404).json({\n        success: false,\n        message: \'Exam not found\',\n      });\n    }\n\n    // Get exam subjects\n    const subjects = await db\n      .select({\n        id: examSubjects.id,\n        examDate: examSubjects.examDate,\n        startTime: examSubjects.startTime,\n        endTime: examSubjects.endTime,\n        duration: examSubjects.duration,\n        totalMarks: examSubjects.totalMarks,\n        passingMarks: examSubjects.passingMarks,\n        roomNumber: examSubjects.roomNumber,\n        class: {\n          id: classes.id,\n          name: classes.name,\n        },\n        section: {\n          id: sections.id,\n          name: sections.name,\n        },\n        subject: {\n          id: subjects.id,\n          name: subjects.name,\n          code: subjects.code,\n        },\n      })\n      .from(examSubjects)\n      .leftJoin(classes, eq(examSubjects.classId, classes.id))\n      .leftJoin(sections, eq(examSubjects.sectionId, sections.id))\n      .leftJoin(subjects, eq(examSubjects.subjectId, subjects.id))\n      .where(eq(examSubjects.examId, id));\n\n    res.status(200).json({\n      success: true,\n      data: {\n        ...exam,\n        subjects,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error fetching exam:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch exam\',\n    });\n  }\n};\n\n// Create exam subject schedule\nexport const createExamSubject = async (req: Request, res: Response) => {\n  try {\n    const {\n      examId,\n      classId,\n      sectionId,\n      subjectId,\n      examDate,\n      startTime,\n      endTime,\n      duration,\n      totalMarks,\n      passingMarks,\n      roomNumber,\n      instructions,\n    } = req.body;\n\n    // Validate required fields\n    if (\n      !examId ||\n      !classId ||\n      !subjectId ||\n      !examDate ||\n      !startTime ||\n      !endTime ||\n      !duration ||\n      !totalMarks ||\n      !passingMarks\n    ) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required fields\',\n      });\n    }\n\n    const [examSubject] = await db\n      .insert(examSubjects)\n      .values({\n        examId,\n        classId,\n        sectionId: sectionId || null,\n        subjectId,\n        examDate,\n        startTime,\n        endTime,\n        duration,\n        totalMarks,\n        passingMarks,\n        roomNumber: roomNumber || null,\n        instructions: instructions || null,\n      })\n      .returning();\n\n    res.status(201).json({\n      success: true,\n      message: \'Exam subject created successfully\',\n      data: examSubject,\n    });\n  } catch (error) {\n    console.error(\'Error creating exam subject:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to create exam subject\',\n    });\n  }\n};\n\n// Get students for marks entry\nexport const getStudentsForMarksEntry = async (req: Request, res: Response) => {\n  try {\n    const { examSubjectId } = req.params;\n\n    // Get exam subject details\n    const [examSubject] = await db\n      .select()\n      .from(examSubjects)\n      .where(eq(examSubjects.id, examSubjectId));\n\n    if (!examSubject) {\n      return res.status(404).json({\n        success: false,\n        message: \'Exam subject not found\',\n      });\n    }\n\n    // Get students enrolled in the class/section\n    const studentsQuery = db\n      .select({\n        id: students.id,\n        studentId: students.studentId,\n        name: sql<string>`${users.firstName} || \' \' || ${users.lastName}`,\n        rollNumber: sql<string>`enrollments.roll_number`,\n        marks: marks.marksObtained,\n        isAbsent: marks.isAbsent,\n        remarks: marks.remarks,\n        markId: marks.id,\n      })\n      .from(students)\n      .leftJoin(users, eq(students.userId, users.id))\n      .leftJoin(sql`enrollments`, and(\n        eq(sql`enrollments.student_id`, students.id),\n        eq(sql`enrollments.class_id`, examSubject.classId),\n        examSubject.sectionId ? eq(sql`enrollments.section_id`, examSubject.sectionId) : sql`true`\n      ))\n      .leftJoin(marks, and(\n        eq(marks.examSubjectId, examSubjectId),\n        eq(marks.studentId, students.id)\n      ))\n      .where(eq(sql`enrollments.status`, \'active\'))\n      .orderBy(sql`enrollments.roll_number`);\n\n    const studentsList = await studentsQuery;\n\n    res.status(200).json({\n      success: true,\n      data: {\n        examSubject,\n        students: studentsList,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error fetching students for marks entry:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch students\',\n    });\n  }\n};\n\n// Save marks (single or bulk)\nexport const saveMarks = async (req: Request, res: Response) => {\n  try {\n    const { examSubjectId, marksData } = req.body;\n    const enteredBy = req.user!.id;\n\n    // Validate required fields\n    if (!examSubjectId || !marksData || !Array.isArray(marksData)) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required fields\',\n      });\n    }\n\n    // Get exam subject to validate marks\n    const [examSubject] = await db\n      .select()\n      .from(examSubjects)\n      .where(eq(examSubjects.id, examSubjectId));\n\n    if (!examSubject) {\n      return res.status(404).json({\n        success: false,\n        message: \'Exam subject not found\',\n      });\n    }\n\n    // Validate marks\n    for (const mark of marksData) {\n      if (!mark.isAbsent && mark.marksObtained > examSubject.totalMarks) {\n        return res.status(400).json({\n          success: false,\n          message: `Marks cannot exceed total marks (${examSubject.totalMarks})`,\n        });\n      }\n    }\n\n    // Process each mark entry\n    for (const mark of marksData) {\n      const existingMark = await db\n        .select()\n        .from(marks)\n        .where(\n          and(\n            eq(marks.examSubjectId, examSubjectId),\n            eq(marks.studentId, mark.studentId)\n          )\n        );\n\n      if (existingMark.length > 0) {\n        // Update existing mark\n        await db\n          .update(marks)\n          .set({\n            marksObtained: mark.isAbsent ? null : mark.marksObtained,\n            isAbsent: mark.isAbsent || false,\n            remarks: mark.remarks || null,\n            enteredBy,\n            updatedAt: new Date(),\n          })\n          .where(eq(marks.id, existingMark[0].id));\n      } else {\n        // Insert new mark\n        await db.insert(marks).values({\n          examSubjectId,\n          studentId: mark.studentId,\n          marksObtained: mark.isAbsent ? null : mark.marksObtained,\n          isAbsent: mark.isAbsent || false,\n          remarks: mark.remarks || null,\n          enteredBy,\n        });\n      }\n    }\n\n    res.status(200).json({\n      success: true,\n      message: \'Marks saved successfully\',\n    });\n  } catch (error) {\n    console.error(\'Error saving marks:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to save marks\',\n    });\n  }\n};\n\n// Get grading system\nexport const getGradingSystem = async (req: Request, res: Response) => {\n  try {\n    const grades = await db\n      .select()\n      .from(gradingSystem)\n      .where(eq(gradingSystem.isActive, true))\n      .orderBy(desc(gradingSystem.gradePoint));\n\n    res.status(200).json({\n      success: true,\n      data: grades,\n    });\n  } catch (error) {\n    console.error(\'Error fetching grading system:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch grading system\',\n    });\n  }\n};\n\n// Calculate grade based on percentage\nconst calculateGrade = async (percentage: number) => {\n  const grades = await db\n    .select()\n    .from(gradingSystem)\n    .where(eq(gradingSystem.isActive, true))\n    .orderBy(desc(gradingSystem.gradePoint));\n\n  for (const grade of grades) {\n    const minPer = parseFloat(grade.minPercentage);\n    const maxPer = parseFloat(grade.maxPercentage);\n    if (percentage >= minPer && percentage <= maxPer) {\n      return {\n        grade: grade.grade,\n        gradePoint: parseFloat(grade.gradePoint),\n      };\n    }\n  }\n\n  return { grade: \'F\', gradePoint: 0 };\n};\n\n// Process results for an exam\nexport const processResults = async (req: Request, res: Response) => {\n  try {\n    const { examId, classId, sectionId } = req.body;\n\n    // Validate required fields\n    if (!examId || !classId) {\n      return res.status(400).json({\n        success: false,\n        message: \'Missing required fields\',\n      });\n    }\n\n    // Get all exam subjects for this class\n    let examSubjectsQuery = db\n      .select()\n      .from(examSubjects)\n      .where(\n        and(\n          eq(examSubjects.examId, examId),\n          eq(examSubjects.classId, classId)\n        )\n      );\n\n    if (sectionId) {\n      examSubjectsQuery = examSubjectsQuery.where(\n        and(\n          eq(examSubjects.examId, examId),\n          eq(examSubjects.classId, classId),\n          eq(examSubjects.sectionId, sectionId)\n        )\n      );\n    }\n\n    const examSubjectsList = await examSubjectsQuery;\n\n    if (examSubjectsList.length === 0) {\n      return res.status(404).json({\n        success: false,\n        message: \'No exam subjects found\',\n      });\n    }\n\n    const examSubjectIds = examSubjectsList.map(es => es.id);\n\n    // Get all marks for these exam subjects\n    const allMarks = await db\n      .select()\n      .from(marks)\n      .where(inArray(marks.examSubjectId, examSubjectIds));\n\n    // Group marks by student\n    const studentMarks: Record<string, any[]> = {};\n    allMarks.forEach(mark => {\n      if (!studentMarks[mark.studentId]) {\n        studentMarks[mark.studentId] = [];\n      }\n      studentMarks[mark.studentId].push(mark);\n    });\n\n    // Calculate results for each student\n    const resultsData = [];\n    for (const [studentId, marks] of Object.entries(studentMarks)) {\n      let totalMarks = 0;\n      let marksObtained = 0;\n      const subjectResultsData = [];\n\n      for (const mark of marks) {\n        const examSubject = examSubjectsList.find(es => es.id === mark.examSubjectId);\n        if (!examSubject) continue;\n\n        totalMarks += examSubject.totalMarks;\n        const obtained = mark.isAbsent ? 0 : parseFloat(mark.marksObtained || \'0\');\n        marksObtained += obtained;\n\n        const subjectPercentage = (obtained / examSubject.totalMarks) * 100;\n        const subjectGrade = await calculateGrade(subjectPercentage);\n\n        subjectResultsData.push({\n          subjectId: examSubject.subjectId,\n          totalMarks: examSubject.totalMarks,\n          marksObtained: obtained,\n          grade: subjectGrade.grade,\n          gradePoint: subjectGrade.gradePoint,\n          isPassed: obtained >= examSubject.passingMarks,\n        });\n      }\n\n      const percentage = (marksObtained / totalMarks) * 100;\n      const overallGrade = await calculateGrade(percentage);\n\n      resultsData.push({\n        studentId,\n        totalMarks,\n        marksObtained,\n        percentage,\n        grade: overallGrade.grade,\n        gradePoint: overallGrade.gradePoint,\n        subjectResults: subjectResultsData,\n      });\n    }\n\n    // Sort by marks obtained for merit position\n    resultsData.sort((a, b) => b.marksObtained - a.marksObtained);\n\n    // Assign merit positions\n    resultsData.forEach((result, index) => {\n      result.meritPosition = index + 1;\n    });\n\n    // Save results to database\n    for (const result of resultsData) {\n      // Check if result already exists\n      const existing = await db\n        .select()\n        .from(results)\n        .where(\n          and(\n            eq(results.examId, examId),\n            eq(results.studentId, result.studentId)\n          )\n        );\n\n      let resultId;\n      if (existing.length > 0) {\n        // Update existing result\n        const [updated] = await db\n          .update(results)\n          .set({\n            totalMarks: result.totalMarks,\n            marksObtained: result.marksObtained.toString(),\n            percentage: result.percentage.toString(),\n            grade: result.grade,\n            gradePoint: result.gradePoint.toString(),\n            meritPosition: result.meritPosition,\n            updatedAt: new Date(),\n          })\n          .where(eq(results.id, existing[0].id))\n          .returning();\n        resultId = updated.id;\n\n        // Delete old subject results\n        await db.delete(subjectResults).where(eq(subjectResults.resultId, resultId));\n      } else {\n        // Insert new result\n        const [newResult] = await db\n          .insert(results)\n          .values({\n            examId,\n            studentId: result.studentId,\n            classId,\n            sectionId: sectionId || null,\n            totalMarks: result.totalMarks,\n            marksObtained: result.marksObtained.toString(),\n            percentage: result.percentage.toString(),\n            grade: result.grade,\n            gradePoint: result.gradePoint.toString(),\n            meritPosition: result.meritPosition,\n            isPublished: false,\n          })\n          .returning();\n        resultId = newResult.id;\n      }\n\n      // Insert subject results\n      for (const subjectResult of result.subjectResults) {\n        await db.insert(subjectResults).values({\n          resultId,\n          subjectId: subjectResult.subjectId,\n          totalMarks: subjectResult.totalMarks,\n          marksObtained: subjectResult.marksObtained.toString(),\n          grade: subjectResult.grade,\n          gradePoint: subjectResult.gradePoint.toString(),\n          isPassed: subjectResult.isPassed,\n        });\n      }\n    }\n\n    res.status(200).json({\n      success: true,\n      message: \'Results processed successfully\',\n      data: {\n        totalStudents: resultsData.length,\n        processed: resultsData.length,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error processing results:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to process results\',\n    });\n  }\n};\n\n// Get student result\nexport const getStudentResult = async (req: Request, res: Response) => {\n  try {\n    const { examId, studentId } = req.params;\n\n    const [result] = await db\n      .select({\n        id: results.id,\n        totalMarks: results.totalMarks,\n        marksObtained: results.marksObtained,\n        percentage: results.percentage,\n        grade: results.grade,\n        gradePoint: results.gradePoint,\n        meritPosition: results.meritPosition,\n        isPublished: results.isPublished,\n        exam: {\n          id: exams.id,\n          name: exams.name,\n          examType: examTypes.name,\n        },\n        class: {\n          id: classes.id,\n          name: classes.name,\n        },\n        section: {\n          id: sections.id,\n          name: sections.name,\n        },\n      })\n      .from(results)\n      .leftJoin(exams, eq(results.examId, exams.id))\n      .leftJoin(examTypes, eq(exams.examTypeId, examTypes.id))\n      .leftJoin(classes, eq(results.classId, classes.id))\n      .leftJoin(sections, eq(results.sectionId, sections.id))\n      .where(\n        and(\n          eq(results.examId, examId),\n          eq(results.studentId, studentId)\n        )\n      );\n\n    if (!result) {\n      return res.status(404).json({\n        success: false,\n        message: \'Result not found\',\n      });\n    }\n\n    // Get subject-wise results\n    const subjectResultsList = await db\n      .select({\n        id: subjectResults.id,\n        totalMarks: subjectResults.totalMarks,\n        marksObtained: subjectResults.marksObtained,\n        grade: subjectResults.grade,\n        gradePoint: subjectResults.gradePoint,\n        isPassed: subjectResults.isPassed,\n        subject: {\n          id: subjects.id,\n          name: subjects.name,\n          code: subjects.code,\n        },\n      })\n      .from(subjectResults)\n      .leftJoin(subjects, eq(subjectResults.subjectId, subjects.id))\n      .where(eq(subjectResults.resultId, result.id));\n\n    res.status(200).json({\n      success: true,\n      data: {\n        ...result,\n        subjectResults: subjectResultsList,\n      },\n    });\n  } catch (error) {\n    console.error(\'Error fetching student result:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to fetch result\',\n    });\n  }\n};\n\n// Publish results\nexport const publishResults = async (req: Request, res: Response) => {\n  try {\n    const { examId } = req.body;\n\n    // Update exam\n    await db\n      .update(exams)\n      .set({ resultsPublished: true, updatedAt: new Date() })\n      .where(eq(exams.id, examId));\n\n    // Update all results for this exam\n    await db\n      .update(results)\n      .set({ isPublished: true, publishedAt: new Date() })\n      .where(eq(results.examId, examId));\n\n    res.status(200).json({\n      success: true,\n      message: \'Results published successfully\',\n    });\n  } catch (error) {\n    console.error(\'Error publishing results:\', error);\n    res.status(500).json({\n      success: false,\n      message: \'Failed to publish results\',\n    });\n  }\n};\n</create-file>\n</function_calls>'}